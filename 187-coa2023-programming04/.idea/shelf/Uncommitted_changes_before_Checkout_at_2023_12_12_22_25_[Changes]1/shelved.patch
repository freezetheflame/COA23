Index: src/main/java/cpu/fpu/FPU.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package cpu.fpu;\r\n\r\nimport util.DataType;\r\nimport util.IEEE754Float;\r\nimport util.Transformer;\r\n\r\nimport java.util.Collections;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * floating point unit\r\n * 执行浮点运算的抽象单元\r\n * 浮点数精度：使用3位保护位进行计算\r\n */\r\npublic class FPU {\r\n\r\n    private final String[][] addCorner = new String[][]{\r\n            {IEEE754Float.P_ZERO, IEEE754Float.P_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.P_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.N_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.N_ZERO, IEEE754Float.N_ZERO},\r\n            {IEEE754Float.P_INF, IEEE754Float.N_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.P_INF, IEEE754Float.NaN}\r\n    };\r\n\r\n    private final String[][] subCorner = new String[][]{\r\n            {IEEE754Float.P_ZERO, IEEE754Float.P_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.P_ZERO, IEEE754Float.N_ZERO},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.N_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.N_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.P_INF, IEEE754Float.P_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.N_INF, IEEE754Float.NaN}\r\n    };\r\n\r\n    private final String[][] mulCorner = new String[][]{\r\n            {IEEE754Float.P_ZERO, IEEE754Float.N_ZERO, IEEE754Float.N_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.P_ZERO, IEEE754Float.N_ZERO},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.P_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.N_ZERO, IEEE754Float.P_ZERO},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.P_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.N_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.P_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.N_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.P_INF, IEEE754Float.P_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.P_INF, IEEE754Float.N_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.P_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.N_ZERO, IEEE754Float.NaN}\r\n    };\r\n\r\n    private final String[][] divCorner = new String[][]{\r\n            {IEEE754Float.P_ZERO, IEEE754Float.P_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.N_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.P_ZERO, IEEE754Float.N_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.N_ZERO, IEEE754Float.P_ZERO, IEEE754Float.NaN},\r\n            {IEEE754Float.P_INF, IEEE754Float.P_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.N_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.P_INF, IEEE754Float.N_INF, IEEE754Float.NaN},\r\n            {IEEE754Float.N_INF, IEEE754Float.P_INF, IEEE754Float.NaN},\r\n    };\r\n\r\n    /**\r\n     * compute the float add of (dest + src)\r\n     */\r\n    public DataType add(DataType src, DataType dest) {\r\n        String destStr = dest.toString();\r\n        String srcStr = src.toString();\r\n        if (destStr.matches(IEEE754Float.NaN_Regular) || srcStr.matches(IEEE754Float.NaN_Regular)) {\r\n            return new DataType(IEEE754Float.NaN);\r\n        }\r\n        String cornerCondition = cornerCheck(addCorner, destStr, srcStr);\r\n        if (null != cornerCondition)\r\n            return new DataType(cornerCondition);\r\n        //corner cases\r\n        String exp1 = destStr.substring(1, 9);\r\n        String exp2 = srcStr.substring(1, 9);\r\n        //get the exp value\r\n        int expVal_1 = Integer.valueOf(exp1, 2);\r\n        int expVal_2 = Integer.valueOf(exp2, 2);\r\n        if (expVal_1 == 255)\r\n            return dest;\r\n        if (expVal_2 == 255)\r\n            return src;\r\n        if (destStr.substring(1).equals(IEEE754Float.P_ZERO.substring(1)))\r\n            return src;\r\n        if (srcStr.substring(1).equals(IEEE754Float.P_ZERO.substring(1)))\r\n            return dest;\r\n        //some other corner cases\r\n        String sig1 = \"\";\r\n        String sig2 = \"\";\r\n        if (expVal_1 == 0) {\r\n            //abnormal\r\n            expVal_1++;\r\n            sig1 += \"0\";\r\n        } else sig1 += \"1\";\r\n        if (expVal_2 == 0) {\r\n            //abnormal\r\n            expVal_2++;\r\n            sig2 += \"0\";\r\n        } else sig2 += \"1\";\r\n        sig1 = sig1 + destStr.substring(9) + \"000\";\r\n        sig2 = sig2 + srcStr.substring(9) + \"000\";\r\n        int expVal = Math.max(expVal_1, expVal_2);\r\n        if (expVal_1 > expVal_2) {\r\n            sig2 = rightShift(sig2, expVal - expVal_2);\r\n        } else {\r\n            sig1 = rightShift(sig1, expVal - expVal_1);\r\n        }\r\n        String temp = signedADD(sig1, sig2, destStr.charAt(0), srcStr.charAt(0));\r\n        String sig = temp.substring(1);\r\n        String sign = temp.substring(0, 1);\r\n        expVal++;\r\n        while (sig.charAt(0) == '0' && expVal > 0) {\r\n            expVal--;//move the point\r\n            sig = sig.substring(1) + '0';//keep the length\r\n        }\r\n        while (!sig.startsWith(\"00000000000000000000000000\") && expVal < 0) {\r\n            expVal++;//if too small move the point and at least the sig has 1 bit\r\n            sig = rightShift(sig, 1);\r\n        }\r\n        if (expVal >= 255)\r\n            return new DataType(sign + \"1111111100000000000000000000000\");\r\n        if (expVal == 0)\r\n            sig = rightShift(sig, 1);\r\n        String exp = Transformer.intToBinary(String.valueOf(expVal)).substring(32 - 8);\r\n        String round = round(sign.charAt(0), exp, sig);\r\n        return new DataType(round);\r\n    }\r\n\r\n    private String signedADD(String sig1, String sig2, char sign1, char sign2) {\r\n        boolean sameSign = sign1 == sign2;\r\n        if (sig1.equals(\"000000000000000000000000000\"))\r\n            return sign2 + sig2;\r\n        if (sig2.equals(\"000000000000000000000000000\"))\r\n            return sign1 + sig1;\r\n\r\n        if (sameSign) {\r\n            int intSig1 = Integer.valueOf(sig1, 2);\r\n            int intSig2 = Integer.valueOf(sig2, 2);\r\n            String intToBinary = Transformer.intToBinary(String.valueOf(intSig1 + intSig2));\r\n            String ansSig = intToBinary.substring(32 - 28);\r\n            return sign1 + ansSig;\r\n        } else {\r\n            int intSig1 = Integer.valueOf(sig1, 2);\r\n            int intSig2 = Integer.valueOf(sig2, 2);\r\n            if (sig1.equals(sig2))\r\n                return \"00000000000000000000000000000\";\r\n            String intToBinary = Transformer.intToBinary(String.valueOf(Math.abs(intSig1 - intSig2)));\r\n            String ansSig = intToBinary.substring(32 - 28);\r\n            return intSig1 > intSig2 ? (sign1 + \"\" + ansSig) : (sign2 + \"\" + ansSig);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * compute the float add of (dest - src)\r\n     */\r\n    public DataType sub(DataType src, DataType dest) {\r\n        String destStr = dest.toString();\r\n        String srcStr = src.toString();\r\n        if(srcStr.charAt(0) == '0')\r\n            srcStr = \"1\" + srcStr.substring(1);\r\n        else srcStr = \"0\" + srcStr.substring(1);\r\n        return add(new DataType(srcStr), dest);\r\n    }\r\n\r\n    /**\r\n     * compute the float mul of (dest * src)\r\n     */\r\n    public DataType mul(DataType src, DataType dest) {\r\n        String srcStr = src.toString();\r\n        String destStr = dest.toString();\r\n        String cornerCheck = cornerCheck(mulCorner, destStr, srcStr);\r\n        if (null != cornerCheck) return new DataType(cornerCheck);\r\n        if(destStr.matches(IEEE754Float.NaN_Regular)||srcStr.matches(IEEE754Float.NaN_Regular))\r\n            return new DataType( IEEE754Float.NaN);\r\n        int exp1 = Integer.valueOf(destStr.substring(1, 9), 2);\r\n        int exp2 = Integer.valueOf(srcStr.substring(1, 9), 2);\r\n        String sig1 = destStr.substring(9);\r\n        String sig2 = srcStr.substring(9);\r\n        //规格化（非IEEE标准）\r\n        if(exp1==0) {\r\n            sig1 = \"0\" + sig1;\r\n            exp1++;\r\n        }else sig1=\"1\"+sig1;\r\n        if(exp2==0){\r\n            sig2=\"0\"+sig2;\r\n            exp2++;\r\n        }else sig2=\"1\"+sig2;\r\n        //get the exponent as add does\r\n        String sign = ((destStr.charAt(0) - '0') ^ (srcStr.charAt(0) - '0')) + \"\";\r\n        //get the sign(final)\r\n        if(exp1==255||exp2==255) return new DataType(sign+\"1111111100000000000000000000000\");\r\n        //corner cases\r\n        int exp=exp1+exp2-126;\r\n        String sigMul = signedMUL(sig1, sig2);\r\n        while (sigMul.charAt(0)=='0'&&exp>0){\r\n            exp--;\r\n            sigMul= sigMul.substring(1) + \"0\";\r\n        }\r\n        while (!sigMul.startsWith(\"000000000000000000000000\")&&exp<0){\r\n            exp++;\r\n            sigMul=rightShift(sigMul,1);\r\n        }\r\n        if(exp>=255)\r\n            return new DataType(sign+\"1111111100000000000000000000000\");\r\n        if(exp==0){\r\n            sigMul=rightShift(sigMul,1);\r\n        }\r\n        if(exp<0)\r\n            return new DataType(sign+\"0000000000000000000000000000000\");\r\n        String expStr=Transformer.intToBinary(String.valueOf(exp)).substring(32-8);\r\n        String round = round(sign.charAt(0), expStr, sigMul);\r\n        return new DataType(round);\r\n    }\r\n    public String nagetify(String val){\r\n        StringBuilder ansBuilder = new StringBuilder();\r\n        for (int i = 0; i < val.length(); i++) {\r\n            ansBuilder.append(val.charAt(i)=='1'?'0':'1');\r\n        }\r\n        return ansBuilder.toString();\r\n    }\r\n    public char getCarry(char x, char y, char c) {\r\n        return (char) (((x - '0') & (y - '0') | (x - '0') & (c - '0') | (c - '0') & (y - '0')) + '0');\r\n    }\r\n\r\n    public char getBit(char x, char y, char c) {\r\n        return ((char) ((x - '0') ^ (y - '0') ^ (c - '0') + '0'));\r\n    }\r\n\r\n    public String carry_adder(String op1, String op2, char c) {\r\n        char carry = c;\r\n        char bit = '0';\r\n        int length = op1.length();\r\n        StringBuilder ansBuilder = new StringBuilder();\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            bit = getBit(op1.charAt(i), op2.charAt(i), carry);\r\n            carry = getCarry(op1.charAt(i), op2.charAt(i), carry);\r\n            ansBuilder.append(bit);\r\n        }\r\n        ansBuilder.append(carry);\r\n        return ansBuilder.reverse().toString();\r\n    }\r\n    private String signedMUL(String sig1,String sig2){\r\n        int length = sig1.length();\r\n        String product=String.join(\"\", Collections.nCopies(length,\"0\"))+sig2;\r\n        //get something like 000000000000 01010101010101010101010101010101\r\n\r\n        for (int i = length-1; i >=0; i--) {\r\n            char now = product.charAt(2*length-1);\r\n            char carry='0';\r\n            if(now=='1'){\r\n                String carryAdder = carry_adder(product.substring(0, length), sig1, '0');\r\n                carry=carryAdder.charAt(0);\r\n                product=carryAdder.substring(1)+product.substring(length);\r\n            }\r\n            product=carry+product.substring(0,2*length-1);\r\n        }\r\n        return product;\r\n    }\r\n    /**\r\n     * compute the float mul of (dest / src)\r\n     */\r\n\r\n\r\n    public DataType div(DataType src, DataType dest) {\r\n        String s = src.toString();\r\n        String d = dest.toString();\r\n        if (IEEE754Float.P_ZERO.equals(s) || IEEE754Float.N_ZERO.equals(s)) {\r\n            if ((!IEEE754Float.P_ZERO.equals(d)) && (!IEEE754Float.N_ZERO.equals(d))) {\r\n                throw new ArithmeticException();\r\n            }\r\n        }\r\n        if(s.matches(IEEE754Float.NaN_Regular)||d.matches(IEEE754Float.NaN_Regular))\r\n            return new DataType(IEEE754Float.NaN);\r\n        String cornerCheck = cornerCheck(divCorner, d, s);\r\n        if (null != cornerCheck)\r\n            return new DataType(cornerCheck);\r\n//        //        0/x\r\n        if (d.equals(IEEE754Float.P_ZERO)) {\r\n            return (s.charAt(0) == '0') ? new DataType(IEEE754Float.P_ZERO) : new DataType(IEEE754Float.N_ZERO);\r\n        } else if (d.equals(IEEE754Float.N_ZERO)) {\r\n            return (s.charAt(0) == '1') ? new DataType(IEEE754Float.P_ZERO) : new DataType(IEEE754Float.N_ZERO);\r\n        }\r\n//        Inf/s\r\n        if (d.equals(IEEE754Float.P_INF)) {\r\n            return (s.charAt(0) == '0') ? new DataType(IEEE754Float.P_INF) : new DataType(IEEE754Float.N_INF);\r\n        } else if (d.equals(IEEE754Float.N_INF)) {\r\n            return (s.charAt(0) == '1') ? new DataType(IEEE754Float.P_INF) : new DataType(IEEE754Float.N_INF);\r\n        }\r\n//        d/inf\r\n        if (s.equals(IEEE754Float.P_INF) || s.equals(IEEE754Float.N_INF)) {\r\n            return (d.charAt(0) == '0') ? new DataType(IEEE754Float.P_ZERO) : new DataType(IEEE754Float.N_ZERO);\r\n        }\r\n        String sign = ((d.charAt(0) - '0') ^ (s.charAt(0) - '0')) + \"\";\r\n\r\n        //get to normal form of divide\r\n        int expLength = 8;\r\n        int sifLength = 23;\r\n        int grsLength = 3;\r\n        int bias = (int) Math.pow(2, expLength - 1) - 1;\r\n        int ExpDE = Integer.parseInt(d.substring(1, 1 + expLength), 2);\r\n        int ExpDor = Integer.parseInt(s.substring(1, 1 + expLength), 2);\r\n        if(ExpDor==0) ExpDor++;\r\n        if(ExpDE==0) ExpDE++;//when it's abnormal\r\n        //then get the \"real\" sig part mainly relies on whether it's normal or not\r\n        String SigDE = d.substring(1 + expLength);\r\n        String SigDor = s.substring(1 + expLength);\r\n        if(d.substring(1,1+expLength).equals(\"00000000\")) SigDE=\"0\"+SigDE;\r\n        else SigDE=\"1\"+SigDE;\r\n        if(s.substring(1,1+expLength).equals(\"00000000\")) SigDor=\"0\"+SigDor;\r\n        else SigDor=\"1\"+SigDor;\r\n        //now the sig part length is 24\r\n        //then get the GRS part\r\n        if(SigDE.length()!=24)\r\n            System.out.println(\"wrong\");\r\n        SigDE+=\"000\";\r\n        SigDor+=\"000\";\r\n        int exponent = ExpDE - ExpDor + bias;\r\n        //get the result of sigb / siga in unsigned form\r\n        //wrap up a function to do the unsigned division\r\n        String result = unsignedDivision(SigDE, SigDor);\r\n        StringBuilder answer = new StringBuilder();\r\n\r\n        while(result.charAt(0)=='0'&&exponent>0){\r\n            result  = leftShift(result,\"1\");\r\n            exponent -- ;\r\n        }\r\n        while(!allZero(result.substring(0,24))&&exponent<0){\r\n            result = rightShift(result,1);\r\n            exponent++;\r\n        }\r\n        if(exponent>=255)\r\n            return new DataType(sign+\"1111111100000000000000000000000\");\r\n        if(exponent==0)\r\n            result = rightShift(result,1);\r\n        if(exponent<0) {\r\n            answer.append(sign);\r\n            answer.append(\"0000000000000000000000000000000\");\r\n            return new DataType(answer.toString());\r\n        }\r\n\r\n        String ans_exponent = Integer.toBinaryString(exponent);\r\n        int len = ans_exponent.length();\r\n        for (int i = 0; i < expLength - len; i++) ans_exponent = \"0\" + ans_exponent;  //补齐到eLength长度\r\n        return new DataType(round(sign.charAt(0), ans_exponent, result));\r\n    }\r\n\r\n    public boolean allZero(String string) {\r\n        for (char c : string.toCharArray()) {\r\n            if (c != '0') return false;\r\n        }\r\n        return true;\r\n    }\r\n    private String unsignedDiv(String DivideEnd,String Divisor){\r\n        String result = \"\";\r\n        String product = DivideEnd;\r\n        for(int i = 0;i < DivideEnd.length();i++)product+=\"0\";\r\n        for(int i = 0;i < DivideEnd.length();i++){\r\n            //calculate the answer by carry\r\n            String temp  = Carry_adder(product.substring(0,DivideEnd.length()),nagetify(Divisor),'1',Divisor.length()).substring(1);\r\n            if(temp.charAt(0)=='0')product = temp.substring(1)+ product.substring(DivideEnd.length())+\"1\";\r\n            else\r\n                product = leftShift(product,\"1\");\r\n        }\r\n        result = product.substring(DivideEnd.length());\r\n        return result;\r\n    }\r\n    public String unsignedDivision(String operand1, String operand2) {\r\n        String quotient = \"\";\r\n        String product = operand1;  //0扩展\r\n        for (int i = 0; i < operand1.length(); i++) product += \"0\";  //直接在后面加0\r\n        for (int i = 0; i < operand1.length(); i++) {\r\n            String temp = Carry_adder(product.substring(0, operand1.length()), nagetify(operand2), '1', operand2.length()).substring(1);\r\n            if (temp.charAt(0) == '0') product = temp.substring(1) + product.substring(operand1.length()) + \"1\";\r\n            else product = leftShift(product, \"1\");\r\n        }\r\n        quotient = product.substring(operand1.length());\r\n        return quotient;\r\n    }\r\n\r\n    public String Carry_adder(String operand1, String operand2, char c, int length) {\r\n        operand1 = impleDigits(operand1, length);\r\n        operand2 = impleDigits(operand2, length);\r\n        String res = \"\";\r\n        char carry = c;\r\n        for (int i = length - 1; i >= 0; i--) {  //这里length不一定是4的倍数，采用更加通用的加法算法\r\n            String temp = fullAdder(operand1.charAt(i), operand2.charAt(i), carry);\r\n            carry = temp.charAt(0);\r\n            res = temp.charAt(1) + res;\r\n        }\r\n        return carry + res;  //注意这个方法里面溢出即有进位\r\n    }\r\n    private String impleDigits(String operand, int length) {\r\n        int len = length - operand.length();\r\n        char imple = operand.charAt(0);\r\n        StringBuffer res = new StringBuffer(new StringBuffer(operand).reverse());\r\n        for (int i = 0; i < len; i++) {\r\n            res = res.append(imple);\r\n        }\r\n        return res.reverse().toString();\r\n    }\r\n\r\n    public String fullAdder(char x, char y, char c) {\r\n        int bit = (x - '0') ^ (y - '0') ^ (c - '0');  //三位异或\r\n        int carry = ((x - '0') & (y - '0')) | ((y - '0') & (c - '0')) | ((x - '0') & (c - '0'));  //有两位为1则产生进位\r\n        return \"\" + carry + bit;  //第一个空串让后面的加法都变为字符串加法\r\n    }\r\n    public String leftShift(String operand, String n) {\r\n        StringBuffer result = new StringBuffer(operand.substring(Integer.parseInt(n)));  //保证位数不变\r\n        for (int i = 0; i < Integer.parseInt(n); i++) {\r\n            result = result.append(\"0\");\r\n        }\r\n        return result.toString();\r\n    }\r\n    /**\r\n     * check corner cases of mul and div\r\n     *\r\n     * @param cornerMatrix corner cases pre-stored\r\n     * @param oprA         first operand (String)\r\n     * @param oprB         second operand (String)\r\n     * @return the result of the corner case (String)\r\n     */\r\n    private String cornerCheck(String[][] cornerMatrix, String oprA, String oprB) {\r\n        for (String[] matrix : cornerMatrix) {\r\n            if (oprA.equals(matrix[0]) && oprB.equals(matrix[1])) {\r\n                return matrix[2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * right shift a num without considering its sign using its string format\r\n     *\r\n     * @param operand to be moved\r\n     * @param n       moving nums of bits\r\n     * @return after moving\r\n     */\r\n    private String rightShift(String operand, int n) {\r\n        StringBuilder result = new StringBuilder(operand);  //保证位数不变\r\n        boolean sticky = false;\r\n        for (int i = 0; i < n; i++) {\r\n            sticky = sticky || result.toString().endsWith(\"1\");\r\n            result.insert(0, \"0\");\r\n            result.deleteCharAt(result.length() - 1);\r\n        }\r\n        if (sticky) {\r\n            result.replace(operand.length() - 1, operand.length(), \"1\");\r\n        }\r\n        return result.substring(0, operand.length());\r\n    }\r\n\r\n    /**\r\n     * 对GRS保护位进行舍入\r\n     *\r\n     * @param sign    符号位\r\n     * @param exp     阶码\r\n     * @param sig_grs 带隐藏位和保护位的尾数\r\n     * @return 舍入后的结果\r\n     */\r\n    private String round(char sign, String exp, String sig_grs) {\r\n        int grs = Integer.parseInt(sig_grs.substring(24, 27), 2);\r\n        if ((sig_grs.substring(27).contains(\"1\")) && (grs % 2 == 0)) {\r\n            grs++;\r\n        }\r\n        String sig = sig_grs.substring(0, 24); // 隐藏位+23位\r\n        if (grs > 4) {\r\n            sig = oneAdder(sig);\r\n        } else if (grs == 4 && sig.endsWith(\"1\")) {\r\n            sig = oneAdder(sig);\r\n        }\r\n\r\n        if (Integer.parseInt(sig.substring(0, sig.length() - 23), 2) > 1) {\r\n            sig = rightShift(sig, 1);\r\n            exp = oneAdder(exp).substring(1);\r\n        }\r\n        if (exp.equals(\"11111111\")) {\r\n            return sign == '0' ? IEEE754Float.P_INF : IEEE754Float.N_INF;\r\n        }\r\n\r\n        return sign + exp + sig.substring(sig.length() - 23);\r\n    }\r\n\r\n    /**\r\n     * add one to the operand\r\n     *\r\n     * @param operand the operand\r\n     * @return result after adding, the first position means overflow (not equal to the carry to the next)\r\n     * and the remains means the result\r\n     */\r\n    private String oneAdder(String operand) {\r\n        int len = operand.length();\r\n        StringBuilder temp = new StringBuilder(operand);\r\n        temp.reverse();\r\n        int[] num = new int[len];\r\n        for (int i = 0; i < len; i++) num[i] = temp.charAt(i) - '0';  //先转化为反转后对应的int数组\r\n        int bit = 0x0;\r\n        int carry = 0x1;\r\n        char[] res = new char[len];\r\n        for (int i = 0; i < len; i++) {\r\n            bit = num[i] ^ carry;\r\n            carry = num[i] & carry;\r\n            res[i] = (char) ('0' + bit);  //显示转化为char\r\n        }\r\n        String result = new StringBuffer(new String(res)).reverse().toString();\r\n        return \"\" + (result.charAt(0) == operand.charAt(0) ? '0' : '1') + result;  //注意有进位不等于溢出，溢出要另外判断\r\n    }\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n//        String a = scanner.next();\r\n//        String b = scanner.next();\r\n        String a = \"5.0\";\r\n        String b = \"20.0\";\r\n        System.out.println(b+\"/\"+a);\r\n        FPU fpu = new FPU();\r\n        System.out.println(Transformer.floatToBinary(a));\r\n        System.out.println(Transformer.floatToBinary(b));\r\n        System.out.println(\"test the unsigned div \"+fpu.unsignedDiv(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));\r\n        System.out.println(\"test the uns division \"+fpu.unsignedDivision(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));\r\n        DataType dest = new DataType(Transformer.floatToBinary( a ));\r\n        DataType src = new DataType(Transformer.floatToBinary( b ));\r\n        DataType result = fpu.div(src, dest);\r\n\r\n        float ans = Float.parseFloat(b)/Float.parseFloat(a);\r\n        System.out.print(\"\\n\");\r\n        System.out.println(\"ans is \"+ans);\r\n        String ansBinary = Transformer.floatToBinary(String.valueOf(ans));\r\n        System.out.println(\"My answer is \"+ result.toString());\r\n        System.out.println(\"ansBinary is \"+ansBinary);\r\n        //Expected :01000000100000000000000000000000\r\n        //Actual   :01000000111001100110011001100110\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/cpu/fpu/FPU.java b/src/main/java/cpu/fpu/FPU.java
--- a/src/main/java/cpu/fpu/FPU.java	
+++ b/src/main/java/cpu/fpu/FPU.java	
@@ -149,7 +149,9 @@
             return intSig1 > intSig2 ? (sign1 + "" + ansSig) : (sign2 + "" + ansSig);
         }
     }
-
+    private String signedadd(String sig1, String sig2, char sign1, char sign2) {
+        return null;
+    }
     /**
      * compute the float add of (dest - src)
      */
@@ -317,7 +319,7 @@
         int exponent = ExpDE - ExpDor + bias;
         //get the result of sigb / siga in unsigned form
         //wrap up a function to do the unsigned division
-        String result = unsignedDivision(SigDE, SigDor);
+        String result = unsignedDiv(SigDE, SigDor);
         StringBuilder answer = new StringBuilder();
 
         while(result.charAt(0)=='0'&&exponent>0){
@@ -369,20 +371,21 @@
         String product = operand1;  //0扩展
         for (int i = 0; i < operand1.length(); i++) product += "0";  //直接在后面加0
         for (int i = 0; i < operand1.length(); i++) {
-            String temp = Carry_adder(product.substring(0, operand1.length()), nagetify(operand2), '1', operand2.length()).substring(1);
+            String temp = Carry_adder(product.substring(0, operand1.length()), nagetify("0"+operand2), '1', operand2.length()+1).substring(1);
             if (temp.charAt(0) == '0') product = temp.substring(1) + product.substring(operand1.length()) + "1";
             else product = leftShift(product, "1");
         }
         quotient = product.substring(operand1.length());
         return quotient;
     }
-
     public String Carry_adder(String operand1, String operand2, char c, int length) {
         operand1 = impleDigits(operand1, length);
+        operand1 = "0"+operand1;
         operand2 = impleDigits(operand2, length);
+        operand2 = "1"+operand2;
         String res = "";
         char carry = c;
-        for (int i = length - 1; i >= 0; i--) {  //这里length不一定是4的倍数，采用更加通用的加法算法
+        for (int i = length ; i >= 1; i--) {
             String temp = fullAdder(operand1.charAt(i), operand2.charAt(i), carry);
             carry = temp.charAt(0);
             res = temp.charAt(1) + res;
@@ -391,7 +394,7 @@
     }
     private String impleDigits(String operand, int length) {
         int len = length - operand.length();
-        char imple = operand.charAt(0);
+        char imple = '0';
         StringBuffer res = new StringBuffer(new StringBuffer(operand).reverse());
         for (int i = 0; i < len; i++) {
             res = res.append(imple);
@@ -505,28 +508,33 @@
         return "" + (result.charAt(0) == operand.charAt(0) ? '0' : '1') + result;  //注意有进位不等于溢出，溢出要另外判断
     }
     public static void main(String[] args) {
-        Scanner scanner = new Scanner(System.in);
-//        String a = scanner.next();
-//        String b = scanner.next();
-        String a = "5.0";
-        String b = "20.0";
-        System.out.println(b+"/"+a);
+//        Scanner scanner = new Scanner(System.in);
+////        String a = scanner.next();
+////        String b = scanner.next();
+//        String a = "5.0";
+//        String b = "20.0";
+//        System.out.println(b+"/"+a);
+//        FPU fpu = new FPU();
+//        System.out.println(Transformer.floatToBinary(a));
+//        System.out.println(Transformer.floatToBinary(b));
+//        System.out.println("test the unsigned div "+fpu.unsignedDiv(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));
+//        System.out.println("test the uns division "+fpu.unsignedDivision(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));
+//        DataType dest = new DataType(Transformer.floatToBinary( a ));
+//        DataType src = new DataType(Transformer.floatToBinary( b ));
+//        DataType result = fpu.div(src, dest);
+//
+//        float ans = Float.parseFloat(b)/Float.parseFloat(a);
+//        System.out.print("\n");
+//        System.out.println("ans is "+ans);
+//        String ansBinary = Transformer.floatToBinary(String.valueOf(ans));
+//        System.out.println("My answer is "+ result.toString());
+//        System.out.println("ansBinary is "+ansBinary);
+//        //Expected :01000000100000000000000000000000
+//        //Actual   :01000000111001100110011001100110
+        //test signedADD
         FPU fpu = new FPU();
-        System.out.println(Transformer.floatToBinary(a));
-        System.out.println(Transformer.floatToBinary(b));
-        System.out.println("test the unsigned div "+fpu.unsignedDiv(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));
-        System.out.println("test the uns division "+fpu.unsignedDivision(Transformer.floatToBinary(b),Transformer.floatToBinary(a)));
-        DataType dest = new DataType(Transformer.floatToBinary( a ));
-        DataType src = new DataType(Transformer.floatToBinary( b ));
-        DataType result = fpu.div(src, dest);
-
-        float ans = Float.parseFloat(b)/Float.parseFloat(a);
-        System.out.print("\n");
-        System.out.println("ans is "+ans);
-        String ansBinary = Transformer.floatToBinary(String.valueOf(ans));
-        System.out.println("My answer is "+ result.toString());
-        System.out.println("ansBinary is "+ansBinary);
-        //Expected :01000000100000000000000000000000
-        //Actual   :01000000111001100110011001100110
+        String a = "1010000000000000000000";
+        String b = "101000000000000000000000000";
+        System.out.println(fpu.signedADD(a,b,'0','1'));
     }
 }
